{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"haskell.nix \u00b6 haskell.nix is an alternative Haskell infrastructure for Nix 1 . Features \u00b6 autogenerate Nix expressions for Cabal project autogenerate Nix expressions for Stack overridable configuration cross-compilation See [Nixpkgs current Users' Guide to Haskell Infrastructure][nixpkgs] for comparison. [nixpkgs]: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure \u21a9","title":"Introduction"},{"location":"#haskellnix","text":"haskell.nix is an alternative Haskell infrastructure for Nix 1 .","title":"haskell.nix"},{"location":"#features","text":"autogenerate Nix expressions for Cabal project autogenerate Nix expressions for Stack overridable configuration cross-compilation See [Nixpkgs current Users' Guide to Haskell Infrastructure][nixpkgs] for comparison. [nixpkgs]: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure \u21a9","title":"Features"},{"location":"architecture/","text":"Architecture \u00b6 There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |---> | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '--> .----------. <-' .--------------. | | plan-to-nix |----> | plan.nix |------.---> | pkgs.nix | <--- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |---> | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram nix-tools \u00b6 nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix . haskell.nix \u00b6 Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own. hackage.nix \u00b6 hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage. stackage.nix \u00b6 stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |---> | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '--> .----------. <-' .--------------. | | plan-to-nix |----> | plan.nix |------.---> | pkgs.nix | <--- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |---> | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram","title":"Architecture"},{"location":"architecture/#nix-tools","text":"nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix .","title":"nix-tools"},{"location":"architecture/#haskellnix","text":"Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own.","title":"haskell.nix"},{"location":"architecture/#hackagenix","text":"hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage.","title":"hackage.nix"},{"location":"architecture/#stackagenix","text":"stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"stackage.nix"},{"location":"changelog/","text":"This file contains a summary of changes to Haskell.nix and nix-tools that will impact users. December 27, 2019 \u00b6 Fix overlays/bootstrap.nix to provide LLVM 6, not LLVM 5, to ghc-8.6.X compilers. November 18, 2019 \u00b6 Changed the cleanSourceHaskell to accept an attrset of src and (optional) name parameters. This allows you to keep the source derivation name constant, so that your builds are always cached. Usage of cleanSourceHaskell will need to be updated. October 12, 2019 \u00b6 shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } . August 9, 2019 \u00b6 Add the haskellLib.collectComponents function. June 21, 2019 \u00b6 Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes. June 7, 2019 \u00b6 Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages. May 29, 2019 \u00b6 Added shellFor function to package set. May 28, 2019 \u00b6 Added snaphots and haskellPackages attributes to the Haskell.nix top-level. May 22, 2019 \u00b6 Add the cleanSourceHaskell utility function to the Haskell.nix top-level. May 21, 2019 \u00b6 Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo. May 20, 2019 \u00b6 Remove Travis CI in favour of Buildkite. May 17, 2019 \u00b6 Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually. Mar 15, 2019 \u00b6 overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"ChangeLog"},{"location":"changelog/#december-27-2019","text":"Fix overlays/bootstrap.nix to provide LLVM 6, not LLVM 5, to ghc-8.6.X compilers.","title":"December 27, 2019"},{"location":"changelog/#november-18-2019","text":"Changed the cleanSourceHaskell to accept an attrset of src and (optional) name parameters. This allows you to keep the source derivation name constant, so that your builds are always cached. Usage of cleanSourceHaskell will need to be updated.","title":"November 18, 2019"},{"location":"changelog/#october-12-2019","text":"shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } .","title":"October 12, 2019"},{"location":"changelog/#august-9-2019","text":"Add the haskellLib.collectComponents function.","title":"August 9, 2019"},{"location":"changelog/#june-21-2019","text":"Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes.","title":"June 21, 2019"},{"location":"changelog/#june-7-2019","text":"Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages.","title":"June 7, 2019"},{"location":"changelog/#may-29-2019","text":"Added shellFor function to package set.","title":"May 29, 2019"},{"location":"changelog/#may-28-2019","text":"Added snaphots and haskellPackages attributes to the Haskell.nix top-level.","title":"May 28, 2019"},{"location":"changelog/#may-22-2019","text":"Add the cleanSourceHaskell utility function to the Haskell.nix top-level.","title":"May 22, 2019"},{"location":"changelog/#may-21-2019","text":"Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo.","title":"May 21, 2019"},{"location":"changelog/#may-20-2019","text":"Remove Travis CI in favour of Buildkite.","title":"May 20, 2019"},{"location":"changelog/#may-17-2019","text":"Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually.","title":"May 17, 2019"},{"location":"changelog/#mar-15-2019","text":"overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"Mar 15, 2019"},{"location":"iohk-nix/","text":"IOHK's nix tooling \u00b6 iohk-nix \u00b6 iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval <iohk_nix>; in if try.success then builtins.trace \"using host <iohk_nix>\" try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = \"${spec.url}/archive/${spec.rev}.tar.gz\"; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { \"url\": \"https://github.com/input-output-hk/iohk-nix\", \"rev\": \"c92f0119ef5814b0ed1f445c2fdcf8894e326294\", \"sha256\": \"05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm\", \"fetchSubmodules\": false } nix/pkgs.nix { pkgs ? import <nixpkgs> {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"IOHKs nix library"},{"location":"iohk-nix/#iohks-nix-tooling","text":"","title":"IOHK's nix tooling"},{"location":"iohk-nix/#iohk-nix","text":"iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval <iohk_nix>; in if try.success then builtins.trace \"using host <iohk_nix>\" try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = \"${spec.url}/archive/${spec.rev}.tar.gz\"; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { \"url\": \"https://github.com/input-output-hk/iohk-nix\", \"rev\": \"c92f0119ef5814b0ed1f445c2fdcf8894e326294\", \"sha256\": \"05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm\", \"fetchSubmodules\": false } nix/pkgs.nix { pkgs ? import <nixpkgs> {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"iohk-nix"},{"location":"motivation/","text":"Motivation \u00b6 Why do we need another Haskell infrastructure for Nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? Problems with the nixpkgs haskell infrastructure are covered in the following sections: Cross compilation \u00b6 nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time. Package sets \u00b6 We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set. Per component level control \u00b6 The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue. Cyclic dependencies \u00b6 The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components. Build times \u00b6 The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum. More logic in nix \u00b6 The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date. Decoupling \u00b6 Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Motivation"},{"location":"motivation/#motivation","text":"Why do we need another Haskell infrastructure for Nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? Problems with the nixpkgs haskell infrastructure are covered in the following sections:","title":"Motivation"},{"location":"motivation/#cross-compilation","text":"nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time.","title":"Cross compilation"},{"location":"motivation/#package-sets","text":"We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set.","title":"Package sets"},{"location":"motivation/#per-component-level-control","text":"The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue.","title":"Per component level control"},{"location":"motivation/#cyclic-dependencies","text":"The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.","title":"Cyclic dependencies"},{"location":"motivation/#build-times","text":"The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum.","title":"Build times"},{"location":"motivation/#more-logic-in-nix","text":"The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date.","title":"More logic in nix"},{"location":"motivation/#decoupling","text":"Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Decoupling"},{"location":"user-guide/","text":"User Guide \u00b6 Haskell.nix can be use for two different use cases: Use 1 : to build a specific package from hackage or a stackage lts or nightly set. \u00b6 To build a package, say lens , from a stackage snapshot, say lts-13.28 , you could run nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; haskell-nix.snapshots.\"lts-13.28\").lens.components.library' which would build the lens library component from the lens package as fixed by the lts-13.28 stackage snapshot. To build any package from hackage, say lens , in version, say 4.17.1, you could run nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; })).components.library' which would build the lens library component from the lens-4.17.1 package from hackage. The dependencies would be solved against the most recent hackage-index-state that comes via the hackage.nix pin with your haskell.nix checkout. A specific one can be specified as well: nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; index-state = \"2019-07-14T00:00:00Z\"; })).components.library' which would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package. Use 2 : to build a stack or cabal project. \u00b6 So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build . Installing nix-tools \u00b6 To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz pkgs.haskell-nix.nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt Getting the Haskell.nix source (optional) \u00b6 The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . pkgs.haskell-nix.nix-tools --arg sourcesOverride '{ nix-tools = ../nix-tools; }' --out-link nt Setting up the Cachix binary cache \u00b6 CI pushes to cachix so you can benefit from the cache if you pin a combination of haskell.nix and nixpkgs built by CI. You'll need to configure the iohk cachix as a substituter for nix and add the public key found at the url to trusted-public-keys . Using Haskell.nix with your project \u00b6 The easiest way to get a hold of Haskell.nix is with fetchTarball . import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs Using your cabal.project file \u00b6 If your project has a cabal.project you can add a default.nix like this: { pkgs ? import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs , compiler-nix-name ? \"ghc865\" }: pkgs.haskell-nix.cabalProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; inherit compiler-nix-name; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `cabal.project` # ]; # modules = [{ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `cabal.project` instead # # (`plan-to-nix` will include them as defaults). # }]; } Note: The cleanGit call will exclude any files not in the index file in the local .git directory. This is extremely useful as it avoids unwanted builds (for instance when the contents of dist-newstyle are modified by cabal). It is important that src is the root directory of the repo (so cleanGit can find the .git directory). If the project is not at the root of the repo, then also pass subDir to cleanGit with the location of the project relative to src as a string ( more information on using cleanGit ). For example: src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; subDir = \"subdir/another-subdir\"; }; If you want to use a custom filtering function, don't use the built-in nix filterSource function. Due to some technicalities about how filtering and the nix store work, it will cause all components in your project to be rebuilt any time any part of the project source changes. Use cleanSourceWith instead: src = pkgs.haskell-nix.haskellLib.cleanSourceWith { src = ./.; filter = myFilterFunction; }; Note that cleanSourceWith will also take the subDir argument. You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello For interactive development you can run: nix-shell -A shellFor The resulting shell will include all the dependencies of the local packages listed in your cabal.project file (but it will not build those local packages). Inside the shell use cabal new-build and cabal new-repl to work on the cabal project as you normally would. They will use the packages provided by nix whenever possible. It is a good idea to add write-ghc-environment-files: never to your cabal.project file to prevent unwanted .ghc.environment.* files (they will prevent subsequent nix-shell invocations from working properly). Adding an index-state to your cabal.project can pin the plan used so that the same packages will be built each time (until you change the index-state or one of the constraints in your local .cabal files). Using your stack.yaml file \u00b6 If your project has a stack.yaml you can add a default.nix like this: { pkgs ? import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs }: pkgs.haskell-nix.stackProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `stack.yaml` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `stack.yaml` instead # # (`stack-to-nix` will include them as defaults). # ]; } You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello Pinning the Haskell.nix version \u00b6 For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { \"url\": \"https://github.com/input-output-hk/haskell.nix\", \"rev\": \"f1a94a4c82a2ab999a67c3b84269da78d89f0075\", \"date\": \"2019-06-05T01:06:12+00:00\", \"sha256\": \"0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla\", \"fetchSubmodules\": false } (The tee command is just to show you the result.) Use the following expression to import that version: { nixpkgs ? <nixpkgs> }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = (import nixpkgs {}).fetchgit { name = \"haskell-lib\"; inherit (spec) url rev sha256 fetchSubmodules; }; in import nixpkgs (import haskell-nix-src) There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal. Overriding the Hackage version \u00b6 Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import <nixpkgs> (haskellNixArgs // { overlays = haskellNixArgs.overlays ++ [ (self: super: { haskell-nix = super.haskell-nix // { hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; }; })]; }) , haskellNixArgs ? (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs }: pkgs Using nix repl \u00b6 It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? <nixpkgs> }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots.\"lts-13.18\"; } Load the example file: $ nix repl '<nixpkgs>' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading '<nixpkgs>'... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl> lib.take 5 pkgNames [ \"ALUT\" \"ANum\" \"Allure\" \"Boolean\" \"BoundedChan\" ] nix-repl> Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Getting Started"},{"location":"user-guide/#user-guide","text":"Haskell.nix can be use for two different use cases:","title":"User Guide"},{"location":"user-guide/#use-1-to-build-a-specific-package-from-hackage-or-a-stackage-lts-or-nightly-set","text":"To build a package, say lens , from a stackage snapshot, say lts-13.28 , you could run nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; haskell-nix.snapshots.\"lts-13.28\").lens.components.library' which would build the lens library component from the lens package as fixed by the lts-13.28 stackage snapshot. To build any package from hackage, say lens , in version, say 4.17.1, you could run nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; })).components.library' which would build the lens library component from the lens-4.17.1 package from hackage. The dependencies would be solved against the most recent hackage-index-state that comes via the hackage.nix pin with your haskell.nix checkout. A specific one can be specified as well: nix build '(with import <nixpkgs> (import ./. {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; index-state = \"2019-07-14T00:00:00Z\"; })).components.library' which would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package.","title":"Use 1 : to build a specific package from hackage or a stackage lts or nightly set."},{"location":"user-guide/#use-2-to-build-a-stack-or-cabal-project","text":"So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build .","title":"Use 2 : to build a stack or cabal project."},{"location":"user-guide/#installing-nix-tools","text":"To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz pkgs.haskell-nix.nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt","title":"Installing nix-tools"},{"location":"user-guide/#getting-the-haskellnix-source-optional","text":"The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . pkgs.haskell-nix.nix-tools --arg sourcesOverride '{ nix-tools = ../nix-tools; }' --out-link nt","title":"Getting the Haskell.nix source (optional)"},{"location":"user-guide/#setting-up-the-cachix-binary-cache","text":"CI pushes to cachix so you can benefit from the cache if you pin a combination of haskell.nix and nixpkgs built by CI. You'll need to configure the iohk cachix as a substituter for nix and add the public key found at the url to trusted-public-keys .","title":"Setting up the Cachix binary cache"},{"location":"user-guide/#using-haskellnix-with-your-project","text":"The easiest way to get a hold of Haskell.nix is with fetchTarball . import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs","title":"Using Haskell.nix with your project"},{"location":"user-guide/#using-your-cabalproject-file","text":"If your project has a cabal.project you can add a default.nix like this: { pkgs ? import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs , compiler-nix-name ? \"ghc865\" }: pkgs.haskell-nix.cabalProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; inherit compiler-nix-name; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `cabal.project` # ]; # modules = [{ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `cabal.project` instead # # (`plan-to-nix` will include them as defaults). # }]; } Note: The cleanGit call will exclude any files not in the index file in the local .git directory. This is extremely useful as it avoids unwanted builds (for instance when the contents of dist-newstyle are modified by cabal). It is important that src is the root directory of the repo (so cleanGit can find the .git directory). If the project is not at the root of the repo, then also pass subDir to cleanGit with the location of the project relative to src as a string ( more information on using cleanGit ). For example: src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; subDir = \"subdir/another-subdir\"; }; If you want to use a custom filtering function, don't use the built-in nix filterSource function. Due to some technicalities about how filtering and the nix store work, it will cause all components in your project to be rebuilt any time any part of the project source changes. Use cleanSourceWith instead: src = pkgs.haskell-nix.haskellLib.cleanSourceWith { src = ./.; filter = myFilterFunction; }; Note that cleanSourceWith will also take the subDir argument. You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello For interactive development you can run: nix-shell -A shellFor The resulting shell will include all the dependencies of the local packages listed in your cabal.project file (but it will not build those local packages). Inside the shell use cabal new-build and cabal new-repl to work on the cabal project as you normally would. They will use the packages provided by nix whenever possible. It is a good idea to add write-ghc-environment-files: never to your cabal.project file to prevent unwanted .ghc.environment.* files (they will prevent subsequent nix-shell invocations from working properly). Adding an index-state to your cabal.project can pin the plan used so that the same packages will be built each time (until you change the index-state or one of the constraints in your local .cabal files).","title":"Using your cabal.project file"},{"location":"user-guide/#using-your-stackyaml-file","text":"If your project has a stack.yaml you can add a default.nix like this: { pkgs ? import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs }: pkgs.haskell-nix.stackProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `stack.yaml` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `stack.yaml` instead # # (`stack-to-nix` will include them as defaults). # ]; } You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello","title":"Using your stack.yaml file"},{"location":"user-guide/#pinning-the-haskellnix-version","text":"For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { \"url\": \"https://github.com/input-output-hk/haskell.nix\", \"rev\": \"f1a94a4c82a2ab999a67c3b84269da78d89f0075\", \"date\": \"2019-06-05T01:06:12+00:00\", \"sha256\": \"0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla\", \"fetchSubmodules\": false } (The tee command is just to show you the result.) Use the following expression to import that version: { nixpkgs ? <nixpkgs> }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = (import nixpkgs {}).fetchgit { name = \"haskell-lib\"; inherit (spec) url rev sha256 fetchSubmodules; }; in import nixpkgs (import haskell-nix-src) There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal.","title":"Pinning the Haskell.nix version"},{"location":"user-guide/#overriding-the-hackage-version","text":"Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import <nixpkgs> (haskellNixArgs // { overlays = haskellNixArgs.overlays ++ [ (self: super: { haskell-nix = super.haskell-nix // { hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; }; })]; }) , haskellNixArgs ? (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs }: pkgs","title":"Overriding the Hackage version"},{"location":"user-guide/#using-nix-repl","text":"It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? <nixpkgs> }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots.\"lts-13.18\"; } Load the example file: $ nix repl '<nixpkgs>' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading '<nixpkgs>'... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl> lib.take 5 pkgNames [ \"ALUT\" \"ANum\" \"Allure\" \"Boolean\" \"BoundedChan\" ] nix-repl> Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Using nix repl"},{"location":"dev/dev-architecture/","text":"Developer Architecture Overview \u00b6 This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble. Packages \u00b6 haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { \"library\" = { depends = [ ... ]; }; exes = { \"...\" = { depends = [ ... ]; }; ... }; sublibs = { \"...\" = { depends = [ ... ]; }; ... }; tests = { \"...\" = { depends = [ ... ]; }; ... }; benchmarks = { \"...\" = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix . Plans \u00b6 Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { \"$pkg\".revision = hackage.$pkg.$version.revisions.default; \"$pkg\".flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = \"8.4.4\"; nix-name = \"ghc844\"; packages = { \"binary\" = \"0.8.5.1\"; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section. Package Sets (of derivations) \u00b6 We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ). Component builder \u00b6 To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Architecture"},{"location":"dev/dev-architecture/#developer-architecture-overview","text":"This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble.","title":"Developer Architecture Overview"},{"location":"dev/dev-architecture/#packages","text":"haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { \"library\" = { depends = [ ... ]; }; exes = { \"...\" = { depends = [ ... ]; }; ... }; sublibs = { \"...\" = { depends = [ ... ]; }; ... }; tests = { \"...\" = { depends = [ ... ]; }; ... }; benchmarks = { \"...\" = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix .","title":"Packages"},{"location":"dev/dev-architecture/#plans","text":"Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { \"$pkg\".revision = hackage.$pkg.$version.revisions.default; \"$pkg\".flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = \"8.4.4\"; nix-name = \"ghc844\"; packages = { \"binary\" = \"0.8.5.1\"; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section.","title":"Plans"},{"location":"dev/dev-architecture/#package-sets-of-derivations","text":"We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ).","title":"Package Sets (of derivations)"},{"location":"dev/dev-architecture/#component-builder","text":"To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Component builder"},{"location":"dev/maintainer-scripts/","text":"Updating Hackage and Stackage Nix expressions \u00b6 The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Maintainer Scripts"},{"location":"dev/maintainer-scripts/#updating-hackage-and-stackage-nix-expressions","text":"The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Updating Hackage and Stackage Nix expressions"},{"location":"dev/nixpkgs-pin/","text":"Haskell.nix Nixpkgs Pin \u00b6 Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Nixpkgs Pin"},{"location":"dev/nixpkgs-pin/#haskellnix-nixpkgs-pin","text":"Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Haskell.nix Nixpkgs Pin"},{"location":"dev/pkg-map/","text":"Mapping non-Haskell dependencies to Nixpkgs \u00b6 Cabal files may contain dependencies to external non-Haskell dependencies via: * build-tool-depends * pkgconfig-depends . * frameworks * extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers. Nixpkgs overlay \u00b6 The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ]; Mapping in Haskell.nix \u00b6 Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"dev/pkg-map/#mapping-non-haskell-dependencies-to-nixpkgs","text":"Cabal files may contain dependencies to external non-Haskell dependencies via: * build-tool-depends * pkgconfig-depends . * frameworks * extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"dev/pkg-map/#nixpkgs-overlay","text":"The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ];","title":"Nixpkgs overlay"},{"location":"dev/pkg-map/#mapping-in-haskellnix","text":"Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping in Haskell.nix"},{"location":"dev/removing-with-package-wrapper/","text":"ghcWithPackages wrapper removal \u00b6 The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone. Plain ghc \u00b6 When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well. ghc-pkg \u00b6 The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set. Setup.hs \u00b6 When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages. cabal new-build \u00b6 Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"Removing withPackage wrapper"},{"location":"dev/removing-with-package-wrapper/#ghcwithpackages-wrapper-removal","text":"The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone.","title":"ghcWithPackages wrapper removal"},{"location":"dev/removing-with-package-wrapper/#plain-ghc","text":"When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well.","title":"Plain ghc"},{"location":"dev/removing-with-package-wrapper/#ghc-pkg","text":"The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set.","title":"ghc-pkg"},{"location":"dev/removing-with-package-wrapper/#setuphs","text":"When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages.","title":"Setup.hs"},{"location":"dev/removing-with-package-wrapper/#cabal-new-build","text":"Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"cabal new-build"},{"location":"dev/tests/","text":"Haskell infrastructure test cases \u00b6 To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh Generated code \u00b6 If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Test Suite"},{"location":"dev/tests/#haskell-infrastructure-test-cases","text":"To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh","title":"Haskell infrastructure test cases"},{"location":"dev/tests/#generated-code","text":"If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Generated code"},{"location":"reference/commands/","text":"stack-to-nix \u00b6 stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: \"stack.yaml\") --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: \".stack-to-nix.cache\") -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ). plan-to-nix \u00b6 plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: \"dist-newstyle/cache/plan.json\") --cabal-project FILE Override path to cabal.project (default: \"cabal.project\") --cache FILE Dependency cache file (default: \".nix-tools.cache\") -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ). cabal-to-nix \u00b6 Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"Command-line tools"},{"location":"reference/commands/#stack-to-nix","text":"stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: \"stack.yaml\") --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: \".stack-to-nix.cache\") -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ).","title":"stack-to-nix"},{"location":"reference/commands/#plan-to-nix","text":"plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: \"dist-newstyle/cache/plan.json\") --cabal-project FILE Override path to cabal.project (default: \"cabal.project\") --cache FILE Dependency cache file (default: \".nix-tools.cache\") -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ).","title":"plan-to-nix"},{"location":"reference/commands/#cabal-to-nix","text":"Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"cabal-to-nix"},{"location":"reference/library/","text":"Haskell.nix contains a library of functions for creating buildable package sets from their Nix expression descriptions. The library is what you get when importing Haskell.nix . It might be helpful to load the library in the Nix REPL to test things. Types \u2014 the kinds of data that you will encounter working with Haskell.nix . Top-level attributes \u2014 Functions and derivations defined in the Haskell.nix attrset. Package-set functions \u2014 Helper functions defined on the hsPkgs package set. Types \u00b6 Package Set \u00b6 The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = \"X.Y.Z\"; nix-name = \"ghcXYZ\"; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset Haskell Package description \u00b6 The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages.<name> in Module options . Component description \u00b6 The component descriptions are values of the pkgSet.config.packages.<package>.components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages.<name>.components.* in Module options . Haskell Package \u00b6 In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; } Component \u00b6 In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package. Haskell.nix also defines a special all component, which is the union of all components in the package. Identifier \u00b6 A package identifier is an attrset pair of name and version . Extras \u00b6 Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions. Modules \u00b6 Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options Top-level attributes \u00b6 mkStackPkgSet \u00b6 Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkCabalProjectPkgSet \u00b6 Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkPkgSet \u00b6 This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet snapshots \u00b6 This is an attrset of hsPkgs packages from Stackage. haskellPackages \u00b6 A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process. nix-tools \u00b6 A derivation containing the nix-tools command-line tools . callStackToNix \u00b6 Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; }; callCabalProjectToNix \u00b6 Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = \"2019-04-30T00:00:00Z\"; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject Path Optional cabal project file (defaults to \"${src}/cabal.project\"). ghc Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use configureArgs String Optional extra arguments to pass to cabal new-configure (--enable-tests is included by default, include --disable-tests to override that). importAndFilterProject \u00b6 Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra). hackage \u00b6 stackage \u00b6 fetchExternal \u00b6 cleanSourceHaskell \u00b6 cleanSourceHaskell = { src, name ? null }: ... Filters a source tree removing common filenames that are not Haskell build sources. This can avoid unecessary rebuilds when these files change. It's recommended to provide name so that the source derivation remains constant regardless of how it was fetched. Example: src = pkgs.haskell-nix.cleanSourceHaskell { src = ./.; name = \"myproject-src\"; }; haskellSourceFilter \u00b6 haskellSourceFilter = name: type: ... This is a source filter function which cleans common build products and files not needed to do a Haskell build from a source directory. It should be used with pkgs.lib.cleanSourceWith . Alternatively, use the convenience function cleanSourceHaskell . haskellLib \u00b6 Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure. collectComponents, collectComponents' \u00b6 Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra (see check if you want to run the tests as well as build them). collectComponents' is an alias of collectComponents without predicate for filtering. collectComponents = group: packageSel: haskellPackages: ... collectComponents' = group: collectComponents (_: true) Argument Type Description group String A sub-component type . packageSel A function Package -> Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents \"tests\" (package: package.identifier.name == \"mypackage\") hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests . collectChecks, collectChecks' \u00b6 These are just like collectComponents and collectComponents' , except that they collect the checks attributes of packages (which aren't components, and so can't be collected by the other functions. check \u00b6 This function turns a derivation that builds a test into one to run it. Argument Type Description drv Derivation One of $pkg.components.tests.$test . For convenience $pkg.components.tests are mapped with this function to $pkg.checks . This function is intended for use with tests but it should also work for exes and benchmarks if you just want to run them to make sure they execute. subComponentTypes \u00b6 Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks Package-set functions \u00b6 These functions exist within the hsPkgs package set. shellFor \u00b6 Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. additional Function Similar to packages , but the selected packages are built and included in ghc-pkg list (not just their dependencies). withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. tools Function AttrSet of tools to make available e.g. { cabal = \"3.2.0.0\"; } or { cabal = { version = \"3.2.0.0\"; }; } { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem. ghcWithPackages \u00b6 Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ]) ghcWithHoogle \u00b6 The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"Haskell.nix Library"},{"location":"reference/library/#types","text":"","title":"Types"},{"location":"reference/library/#package-set","text":"The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = \"X.Y.Z\"; nix-name = \"ghcXYZ\"; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset","title":"Package Set"},{"location":"reference/library/#haskell-package-description","text":"The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages.<name> in Module options .","title":"Haskell Package description"},{"location":"reference/library/#component-description","text":"The component descriptions are values of the pkgSet.config.packages.<package>.components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages.<name>.components.* in Module options .","title":"Component description"},{"location":"reference/library/#haskell-package","text":"In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; }","title":"Haskell Package"},{"location":"reference/library/#component","text":"In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package. Haskell.nix also defines a special all component, which is the union of all components in the package.","title":"Component"},{"location":"reference/library/#identifier","text":"A package identifier is an attrset pair of name and version .","title":"Identifier"},{"location":"reference/library/#extras","text":"Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions.","title":"Extras"},{"location":"reference/library/#modules","text":"Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options","title":"Modules"},{"location":"reference/library/#top-level-attributes","text":"","title":"Top-level attributes"},{"location":"reference/library/#mkstackpkgset","text":"Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkStackPkgSet"},{"location":"reference/library/#mkcabalprojectpkgset","text":"Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkCabalProjectPkgSet"},{"location":"reference/library/#mkpkgset","text":"This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet","title":"mkPkgSet"},{"location":"reference/library/#snapshots","text":"This is an attrset of hsPkgs packages from Stackage.","title":"snapshots"},{"location":"reference/library/#haskellpackages","text":"A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process.","title":"haskellPackages"},{"location":"reference/library/#nix-tools","text":"A derivation containing the nix-tools command-line tools .","title":"nix-tools"},{"location":"reference/library/#callstacktonix","text":"Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; };","title":"callStackToNix"},{"location":"reference/library/#callcabalprojecttonix","text":"Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = \"2019-04-30T00:00:00Z\"; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject Path Optional cabal project file (defaults to \"${src}/cabal.project\"). ghc Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use configureArgs String Optional extra arguments to pass to cabal new-configure (--enable-tests is included by default, include --disable-tests to override that).","title":"callCabalProjectToNix"},{"location":"reference/library/#importandfilterproject","text":"Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).","title":"importAndFilterProject"},{"location":"reference/library/#hackage","text":"","title":"hackage"},{"location":"reference/library/#stackage","text":"","title":"stackage"},{"location":"reference/library/#fetchexternal","text":"","title":"fetchExternal"},{"location":"reference/library/#cleansourcehaskell","text":"cleanSourceHaskell = { src, name ? null }: ... Filters a source tree removing common filenames that are not Haskell build sources. This can avoid unecessary rebuilds when these files change. It's recommended to provide name so that the source derivation remains constant regardless of how it was fetched. Example: src = pkgs.haskell-nix.cleanSourceHaskell { src = ./.; name = \"myproject-src\"; };","title":"cleanSourceHaskell"},{"location":"reference/library/#haskellsourcefilter","text":"haskellSourceFilter = name: type: ... This is a source filter function which cleans common build products and files not needed to do a Haskell build from a source directory. It should be used with pkgs.lib.cleanSourceWith . Alternatively, use the convenience function cleanSourceHaskell .","title":"haskellSourceFilter"},{"location":"reference/library/#haskelllib","text":"Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure.","title":"haskellLib"},{"location":"reference/library/#collectcomponents-collectcomponents","text":"Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra (see check if you want to run the tests as well as build them). collectComponents' is an alias of collectComponents without predicate for filtering. collectComponents = group: packageSel: haskellPackages: ... collectComponents' = group: collectComponents (_: true) Argument Type Description group String A sub-component type . packageSel A function Package -> Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents \"tests\" (package: package.identifier.name == \"mypackage\") hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests .","title":"collectComponents, collectComponents'"},{"location":"reference/library/#collectchecks-collectchecks","text":"These are just like collectComponents and collectComponents' , except that they collect the checks attributes of packages (which aren't components, and so can't be collected by the other functions.","title":"collectChecks, collectChecks'"},{"location":"reference/library/#check","text":"This function turns a derivation that builds a test into one to run it. Argument Type Description drv Derivation One of $pkg.components.tests.$test . For convenience $pkg.components.tests are mapped with this function to $pkg.checks . This function is intended for use with tests but it should also work for exes and benchmarks if you just want to run them to make sure they execute.","title":"check"},{"location":"reference/library/#subcomponenttypes","text":"Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks","title":"subComponentTypes"},{"location":"reference/library/#package-set-functions","text":"These functions exist within the hsPkgs package set.","title":"Package-set functions"},{"location":"reference/library/#shellfor","text":"Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. additional Function Similar to packages , but the selected packages are built and included in ghc-pkg list (not just their dependencies). withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. tools Function AttrSet of tools to make available e.g. { cabal = \"3.2.0.0\"; } or { cabal = { version = \"3.2.0.0\"; }; } { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem.","title":"shellFor"},{"location":"reference/library/#ghcwithpackages","text":"Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])","title":"ghcWithPackages"},{"location":"reference/library/#ghcwithhoogle","text":"The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"ghcWithHoogle"},{"location":"reference/modules-preamble/","text":"Haskell.nix modules options for packages and components. Undocumented Please help write me. This documentation is generated from Nix sources in the modules subdirectory. The Markdown generation script could also be improved.","title":"Modules preamble"},{"location":"reference/modules/","text":"Haskell.nix modules options for packages and components. Undocumented Please help write me. This documentation is generated from Nix sources in the modules subdirectory. The Markdown generation script could also be improved. Configuration Options \u00b6 enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages This option has no description. Type: attribute set of submodules Declared by: modules/plan.nix packages.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.package.author This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.buildType This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.cleanHpack This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.package.copyright This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.dataDir This option has no description. Type: string Default: \"\" Declared by: modules/plan.nix packages.<name>.package.dataFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.description This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.detailLevel This option has no description. Type: string Default: \"MinimalDetails\" Declared by: modules/plan.nix packages.<name>.package.extraDocFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.extraTmpFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.ghcOptions This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.package.homepage This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.identifier.name This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.identifier.version This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.isLocal This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.package.license This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.licenseFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.maintainer This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.setup-depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.specVersion This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.synopsis This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.url This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.cabal-generator This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all The merged dependencies of all other components Type: submodule Declared by: modules/plan.nix packages.<name>.components.all.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.all.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.all.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.all.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.all.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.all.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.benchmarks This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.exes This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.exes.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.library This option has no description. Type: null or submodule Default: null Declared by: modules/plan.nix packages.<name>.components.library.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.library.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.library.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.library.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.library.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.library.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.setup This option has no description. Type: null or submodule Default: ` { asmSources = [ ] ; cSources = [ ] ; cmmSources = [ ] ; cxxSources = [ ] ; depends = [ ] ; doExactConfig = false; extraSrcFiles = [ \"Setup.hs\" \"Setup.lhs\" ] ; frameworks = [ ] ; hsSourceDirs = [ \"setup-src\" ] ; includeDirs = [ ] ; jsSources = [ ] ; libs = [ ] ; platforms = null; } ` Declared by: modules/plan.nix packages.<name>.components.setup.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.setup.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.setup.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.setup.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.setup.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.sublibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.tests This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.tests.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.flags This option has no description. Type: attribute set of booleans Declared by: modules/plan.nix packages.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.name This option has no description. Type: string Default: \"\\${config.package.identifier.name}-\\${config.package.identifier.version}\" Declared by: modules/plan.nix packages.<name>.patches This option has no description. Type: list of unspecified or paths Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.revision This option has no description. Type: null or signed integer Default: null Declared by: modules/plan.nix packages.<name>.revisionSha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.sha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.src This option has no description. Type: path or package Default: ''pkgs.fetchurl { url = \"mirror://hackage/''${config.name}.tar.gz\"; inherit (config) sha256; };'' Declared by: modules/plan.nix packages.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix bootPkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix cabal.compiler This option has no description. Type: unspecified Declared by: modules/cabal.nix cabal.system This option has no description. Type: unspecified Declared by: modules/cabal.nix compiler.packages This option has no description. Type: attribute set of strings Declared by: modules/plan.nix compiler.nix-name This option has no description. Type: string Declared by: modules/plan.nix compiler.version This option has no description. Type: string Declared by: modules/plan.nix configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix errorHandler This option has no description. Type: unspecified Declared by: modules/error-handler.nix ghc.package This option has no description. Type: package Default: \"pkgs.buildPackages.haskell-nix.compiler.\\${config.compiler.nix-name}\" Declared by: modules/hackage.nix hackage.configs This option has no description. Type: unspecified Declared by: modules/hackage.nix hackage.db This option has no description. Type: unspecified Declared by: modules/hackage.nix hsPkgs This option has no description. Type: unspecified Declared by: modules/component-driver.nix keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix nonReinstallablePkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix reinstallableLibGhc Is lib:ghc reinstallable? Type: boolean Default: false Declared by: modules/component-driver.nix setup-depends pkgs to globally provide to Setup.hs builds Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/component-driver.nix setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix","title":"Module options"},{"location":"reference/modules/#configuration-options","text":"enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages This option has no description. Type: attribute set of submodules Declared by: modules/plan.nix packages.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.package.author This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.buildType This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.cleanHpack This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.package.copyright This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.dataDir This option has no description. Type: string Default: \"\" Declared by: modules/plan.nix packages.<name>.package.dataFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.description This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.detailLevel This option has no description. Type: string Default: \"MinimalDetails\" Declared by: modules/plan.nix packages.<name>.package.extraDocFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.extraTmpFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.ghcOptions This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.package.homepage This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.identifier.name This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.identifier.version This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.isLocal This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.package.license This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.licenseFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.maintainer This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.setup-depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.package.specVersion This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.synopsis This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.package.url This option has no description. Type: string Declared by: modules/plan.nix packages.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.cabal-generator This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all The merged dependencies of all other components Type: submodule Declared by: modules/plan.nix packages.<name>.components.all.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.all.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.all.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.all.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.all.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.all.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.all.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.all.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.all.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.all.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.benchmarks This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.benchmarks.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.exes This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.exes.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.exes.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.exes.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.exes.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.exes.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.foreignlibs.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.library This option has no description. Type: null or submodule Default: null Declared by: modules/plan.nix packages.<name>.components.library.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.library.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.library.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.library.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.library.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.library.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.library.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.library.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.library.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.library.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.setup This option has no description. Type: null or submodule Default: ` { asmSources = [ ] ; cSources = [ ] ; cmmSources = [ ] ; cxxSources = [ ] ; depends = [ ] ; doExactConfig = false; extraSrcFiles = [ \"Setup.hs\" \"Setup.lhs\" ] ; frameworks = [ ] ; hsSourceDirs = [ \"setup-src\" ] ; includeDirs = [ ] ; jsSources = [ ] ; libs = [ ] ; platforms = null; } ` Declared by: modules/plan.nix packages.<name>.components.setup.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.setup.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.setup.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.setup.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.setup.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.setup.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.setup.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.setup.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.setup.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.sublibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.sublibs.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.components.tests This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableDeadCodeElimination If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableShared If set, enables building shared libraries. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.enableStatic If set, enables building static libraries and executables. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.components.tests.<name>.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ \".\" ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.components.tests.<name>.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.components.tests.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.components.tests.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.components.tests.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages.<name>.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix packages.<name>.flags This option has no description. Type: attribute set of booleans Declared by: modules/plan.nix packages.<name>.keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix packages.<name>.name This option has no description. Type: string Default: \"\\${config.package.identifier.name}-\\${config.package.identifier.version}\" Declared by: modules/plan.nix packages.<name>.patches This option has no description. Type: list of unspecified or paths Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages.<name>.profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix packages.<name>.revision This option has no description. Type: null or signed integer Default: null Declared by: modules/plan.nix packages.<name>.revisionSha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.sha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages.<name>.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages.<name>.src This option has no description. Type: path or package Default: ''pkgs.fetchurl { url = \"mirror://hackage/''${config.name}.tar.gz\"; inherit (config) sha256; };'' Declared by: modules/plan.nix packages.<name>.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages.<name>.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix bootPkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix cabal.compiler This option has no description. Type: unspecified Declared by: modules/cabal.nix cabal.system This option has no description. Type: unspecified Declared by: modules/cabal.nix compiler.packages This option has no description. Type: attribute set of strings Declared by: modules/plan.nix compiler.nix-name This option has no description. Type: string Declared by: modules/plan.nix compiler.version This option has no description. Type: string Declared by: modules/plan.nix configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix doCheck This option has no description. Type: boolean Default: true Declared by: modules/plan.nix doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix doHoogle Also build a hoogle index. Type: boolean Default: true Declared by: modules/plan.nix doHyperlinkSource Link documentation to the source code. Type: boolean Default: true Declared by: modules/plan.nix dontPatchELF If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type: boolean Default: true Declared by: modules/plan.nix dontStrip If set, libraries and executables are not stripped. Type: boolean Default: true Declared by: modules/plan.nix errorHandler This option has no description. Type: unspecified Declared by: modules/error-handler.nix ghc.package This option has no description. Type: package Default: \"pkgs.buildPackages.haskell-nix.compiler.\\${config.compiler.nix-name}\" Declared by: modules/hackage.nix hackage.configs This option has no description. Type: unspecified Declared by: modules/hackage.nix hackage.db This option has no description. Type: unspecified Declared by: modules/hackage.nix hsPkgs This option has no description. Type: unspecified Declared by: modules/component-driver.nix keepSource Keep component source in the store in a `source` output Type: boolean Default: false Declared by: modules/plan.nix nonReinstallablePkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix profilingDetail This option has no description. Type: null or string Default: \"default\" Declared by: modules/plan.nix reinstallableLibGhc Is lib:ghc reinstallable? Type: boolean Default: false Declared by: modules/component-driver.nix setup-depends pkgs to globally provide to Setup.hs builds Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/component-driver.nix setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix","title":"Configuration Options"},{"location":"user-guide/cabal-projects/","text":"Here we will look into how to generate the pkgs.nix file for a cabal.project project. For the full integration see the previous page . Generating package sets for Cabal projects, is slightly more involved, because you need to let Cabal calculate a build plan for the dependencies of your package(s). Generating plan.json \u00b6 To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run \"cabal new-configure\" If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual . Using plan-to-nix \u00b6 With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description. Creating the package set \u00b6 Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Cabal Projects"},{"location":"user-guide/cabal-projects/#generating-planjson","text":"To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run \"cabal new-configure\" If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual .","title":"Generating plan.json"},{"location":"user-guide/cabal-projects/#using-plan-to-nix","text":"With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description.","title":"Using plan-to-nix"},{"location":"user-guide/cabal-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"},{"location":"user-guide/clean-git/","text":"cleanGit \u00b6 To filter out just the files in your git index use haskell-nix.haskellLib.cleanGit { src = ./.; } where ./. is the root of your git repo (or a git work tree). First it filters just the files needed to run git index , then it uses the results of that to filter your directory. It does not need to parse the .gitignore files at all, but we do need to git add our files before they will be included. cleanGit source . In addition haskell.nix (including cleanGit ) uses a version of cleanSourceWith with a subdir argument to filter out just the package it is building. Then it uses the info from the cabal file to filter just the source dirs for the component it is building. That way if we modify a test in a package nix will not rebuild the library in that package (or anything that depends on that package's library). There is a downside to this though. If we have a test that depends on something outside the scope of what is described in its entry in the in the .cabal file it will not see it. For instance perhaps it needs to run hlint or doctest on the library source. There are ways to fix this with a module: Use extraSrcFiles to add dirs the test needs (this will not result in a change to the .cabal file the test will still be built the same). components.tests.test.extraSrcFiles = [ \"subdir-needed-by-test\" ]; Or alternatively, override the source with a suitable filter function. components.tests.test.src = haskell-nix.haskellLib.cleanSourceWith { inherit src; subdir = \"path-to-package\"; filter = ... }; Multiple Git Repositories with cleanGits \u00b6 Some times it is handy to temporarily use a relative path between git repos. If the repos are individually cleaned this is not possible (since the cleaned version of one repo will never include the files of the other). There are 3 options: We could symlinkJoin the cleaned directories together, but the result could not be cleaned and any change would to either repo would result in a rebuild of everything. We could add one repo to the other as a submodule, but adding and then removing a submodule is a pain and it does not work well if you have more than one repo that needs to share the submodule. We could add a source-repository-package but then we would have to commit each change before testing. cleanGits allows us to specify a root directory and any number of sub directories containing git repos. For example if repoA and repoB are two git repos with cabal packages and want to use the repoB package when building repoA. First we can add ../repoB to repoA/cabal.project`: packages: ./. ../repoB Then in repoA/default.nix we can use: haskell-nix.cabalProject { src = haskell-nix.haskellLib.cleanSourceWith { src = haskell-nix.haskellLib.cleanGits { name = \"root\"; src = ../.; # Parent dir that contains repoA and repoB gitDirs = [ \"repoA\" \"repoB\" ]; }; subDir = \"repoA\"; # Where to look for the `cabal.project` includeSiblings = true; # Tells it not to exclude `repoB` dir }; }","title":"cleanGit"},{"location":"user-guide/clean-git/#cleangit","text":"To filter out just the files in your git index use haskell-nix.haskellLib.cleanGit { src = ./.; } where ./. is the root of your git repo (or a git work tree). First it filters just the files needed to run git index , then it uses the results of that to filter your directory. It does not need to parse the .gitignore files at all, but we do need to git add our files before they will be included. cleanGit source . In addition haskell.nix (including cleanGit ) uses a version of cleanSourceWith with a subdir argument to filter out just the package it is building. Then it uses the info from the cabal file to filter just the source dirs for the component it is building. That way if we modify a test in a package nix will not rebuild the library in that package (or anything that depends on that package's library). There is a downside to this though. If we have a test that depends on something outside the scope of what is described in its entry in the in the .cabal file it will not see it. For instance perhaps it needs to run hlint or doctest on the library source. There are ways to fix this with a module: Use extraSrcFiles to add dirs the test needs (this will not result in a change to the .cabal file the test will still be built the same). components.tests.test.extraSrcFiles = [ \"subdir-needed-by-test\" ]; Or alternatively, override the source with a suitable filter function. components.tests.test.src = haskell-nix.haskellLib.cleanSourceWith { inherit src; subdir = \"path-to-package\"; filter = ... };","title":"cleanGit"},{"location":"user-guide/clean-git/#multiple-git-repositories-with-cleangits","text":"Some times it is handy to temporarily use a relative path between git repos. If the repos are individually cleaned this is not possible (since the cleaned version of one repo will never include the files of the other). There are 3 options: We could symlinkJoin the cleaned directories together, but the result could not be cleaned and any change would to either repo would result in a rebuild of everything. We could add one repo to the other as a submodule, but adding and then removing a submodule is a pain and it does not work well if you have more than one repo that needs to share the submodule. We could add a source-repository-package but then we would have to commit each change before testing. cleanGits allows us to specify a root directory and any number of sub directories containing git repos. For example if repoA and repoB are two git repos with cabal packages and want to use the repoB package when building repoA. First we can add ../repoB to repoA/cabal.project`: packages: ./. ../repoB Then in repoA/default.nix we can use: haskell-nix.cabalProject { src = haskell-nix.haskellLib.cleanSourceWith { src = haskell-nix.haskellLib.cleanGits { name = \"root\"; src = ../.; # Parent dir that contains repoA and repoB gitDirs = [ \"repoA\" \"repoB\" ]; }; subDir = \"repoA\"; # Where to look for the `cabal.project` includeSiblings = true; # Tells it not to exclude `repoB` dir }; }","title":"Multiple Git Repositories with cleanGits"},{"location":"user-guide/cross-compilation/","text":"Cross compilation of Haskell projects involves building a version of GHC that outputs code for the target platform, and providing builds of all library dependencies for that platform. First, understand how to cross-compile a normal package from Nixpkgs. Matthew Bauer's Beginners' guide to cross compilation in Nixpkgs is a useful resource. Using an example from the guide, this builds GNU Hello for a Raspberry Pi: nix build -f '<nixpkgs>' pkgsCross.raspberryPi.hello We will use the same principle in Haskell.nix \u2014 replacing the normal package set pkgs with a cross-compiling package set pkgsCross.raspberryPi . Raspberry Pi example \u00b6 This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on. Note Note that haskell.nix will automatically use qemu to emulate the target when necessary to run Template Haskell splices. Static executables with Musl libc \u00b6 Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ \"--disable-executable-dynamic\" \"--disable-shared\" \"--ghc-option=-optl=-pthread\" \"--ghc-option=-optl=-static\" \"--ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib\" \"--ghc-option=-optl=-L${zlib.static}/lib\" ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this. How to cross-compile your project \u00b6 Set up your project Haskell package set. # default.nix { pkgs ? import <nixpkgs> {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import <nixpkgs> {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import <nixpkgs> { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import <nixpkgs> {}; pkgsRaspberryPi = import <nixpkgs> { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"How to cross-compile your project"},{"location":"user-guide/cross-compilation/#raspberry-pi-example","text":"This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on. Note Note that haskell.nix will automatically use qemu to emulate the target when necessary to run Template Haskell splices.","title":"Raspberry Pi example"},{"location":"user-guide/cross-compilation/#static-executables-with-musl-libc","text":"Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ \"--disable-executable-dynamic\" \"--disable-shared\" \"--ghc-option=-optl=-pthread\" \"--ghc-option=-optl=-static\" \"--ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib\" \"--ghc-option=-optl=-L${zlib.static}/lib\" ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this.","title":"Static executables with Musl libc"},{"location":"user-guide/cross-compilation/#how-to-cross-compile-your-project","text":"Set up your project Haskell package set. # default.nix { pkgs ? import <nixpkgs> {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import <nixpkgs> {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import <nixpkgs> { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import <nixpkgs> {}; pkgsRaspberryPi = import <nixpkgs> { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"How to cross-compile your project"},{"location":"user-guide/development/","text":"Haskell.nix also provides reproducible development environments for your Haskell projects. These environments can contain not only GHC and your Haskell package dependencies, but also the required system libraries and build tools. Inside the development shell, you can run commands such as ghc , ghci , or cabal new\u2011build , and they will have all dependencies available. Every dependency will be cached in your Nix store. If you have set up Hydra CI, then your team can share pre-built dependencies. These examples assume that you have created your package set as described in Creating Nix builds for your projects and it exists in a file called default.nix . Note Old-style cabal build and stack builds are not (yet) supported. For example, stack will (by design) download and rebuild all dependencies, even though they are available in the shell. However, if you have a Stack project, you can generate the package set with Haskell.nix, then use cabal new\u2011build to work on it. How to get a development shell for a package \u00b6 Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all How to get a development shell for a multi-package project \u00b6 If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import <nixpkgs> {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a \"hoogle\" command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). # Some common tools can be added with the `tools` argument tools = { cabal = \"3.2.0.0\"; hlint = \"2.2.11\"; }; # See overlays/tools.nix for more details # Some you may need to get some other way. buildInputs = with pkgs.haskellPackages; [ ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor How to get a local Hoogle index \u00b6 If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 . How to get an ad-hoc development shell including certain packages \u00b6 This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages . How to get packages from a certain Stackage snapshot \u00b6 Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.snapshots.\"lts-13.18\".alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built. Emacs IDE support \u00b6 Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"How to create a development environment"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-package","text":"Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all","title":"How to get a development shell for a package"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-multi-package-project","text":"If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import <nixpkgs> {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a \"hoogle\" command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). # Some common tools can be added with the `tools` argument tools = { cabal = \"3.2.0.0\"; hlint = \"2.2.11\"; }; # See overlays/tools.nix for more details # Some you may need to get some other way. buildInputs = with pkgs.haskellPackages; [ ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor","title":"How to get a development shell for a multi-package project"},{"location":"user-guide/development/#how-to-get-a-local-hoogle-index","text":"If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 .","title":"How to get a local Hoogle index"},{"location":"user-guide/development/#how-to-get-an-ad-hoc-development-shell-including-certain-packages","text":"This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages .","title":"How to get an ad-hoc development shell including certain packages"},{"location":"user-guide/development/#how-to-get-packages-from-a-certain-stackage-snapshot","text":"Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.snapshots.\"lts-13.18\".alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built.","title":"How to get packages from a certain Stackage snapshot"},{"location":"user-guide/development/#emacs-ide-support","text":"Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"Emacs IDE support"},{"location":"user-guide/hackage-stackage/","text":"Hackage and Stackage \u00b6 haskell.nix relies on some generated data providing information about packages in Hackage and Stackage snapshots. These are kept in hackage.nix and stackage.nix respectively. If your project depends on a Hackage package, then the hackage.nix revision used must be new enough to contain that, and likewise for Stackage snaphots and stackage.nix . Updating and pinning hackage.nix and stackage.nix \u00b6 haskell.nix pins particular revisions of these repositories internally, both for our own usage in testing, and so that users have a sensible default when getting started. These revisions are updated nightly, so you can get newer revisions of hackage.nix and stackage.nix by updating your revision of haskell.nix itself. However, this exposes you to changes in haskell.nix which you may not want, such as changes that force compiler rebuilds, or the occasional bug. Instead, you can pin hackage.nix and stackage.nix independently. For example: let # You can use a tool like `niv` to manage this boilerplate hackageSrc = builtins.fetchTarball https://github.com/input-output-hk/hackage.nix/archive/master.tar.gz; stackageSrc = builtins.fetchTarball https://github.com/input-output-hk/stackage.nix/archive/master.tar.gz; haskellSrc = builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz; haskellNix = import haskellSrc { # This allows you to override the pins used by `haskell.nix` internally sourcesOverride = { hackage = hackageSrc; stackage = stackageSrc; }; }; in ... You can then change the revisions that hackage.nix and stackage.nix are fetched from without changing haskell.nix . However, bear in mind that Stackage refers to Hackage, so your Stackage should never be newer than Hackage.","title":"Hackage and Stackage"},{"location":"user-guide/hackage-stackage/#hackage-and-stackage","text":"haskell.nix relies on some generated data providing information about packages in Hackage and Stackage snapshots. These are kept in hackage.nix and stackage.nix respectively. If your project depends on a Hackage package, then the hackage.nix revision used must be new enough to contain that, and likewise for Stackage snaphots and stackage.nix .","title":"Hackage and Stackage"},{"location":"user-guide/hackage-stackage/#updating-and-pinning-hackagenix-and-stackagenix","text":"haskell.nix pins particular revisions of these repositories internally, both for our own usage in testing, and so that users have a sensible default when getting started. These revisions are updated nightly, so you can get newer revisions of hackage.nix and stackage.nix by updating your revision of haskell.nix itself. However, this exposes you to changes in haskell.nix which you may not want, such as changes that force compiler rebuilds, or the occasional bug. Instead, you can pin hackage.nix and stackage.nix independently. For example: let # You can use a tool like `niv` to manage this boilerplate hackageSrc = builtins.fetchTarball https://github.com/input-output-hk/hackage.nix/archive/master.tar.gz; stackageSrc = builtins.fetchTarball https://github.com/input-output-hk/stackage.nix/archive/master.tar.gz; haskellSrc = builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz; haskellNix = import haskellSrc { # This allows you to override the pins used by `haskell.nix` internally sourcesOverride = { hackage = hackageSrc; stackage = stackageSrc; }; }; in ... You can then change the revisions that hackage.nix and stackage.nix are fetched from without changing haskell.nix . However, bear in mind that Stackage refers to Hackage, so your Stackage should never be newer than Hackage.","title":"Updating and pinning hackage.nix and stackage.nix"},{"location":"user-guide/materialization/","text":"Materialization \u00b6 What is materialization? \u00b6 Capturing and storing the nix files for a project so that they do not need to be built (or checked). This allows us to cache the input of an IFD (import from derviation). Why use materialization? \u00b6 Using functions like cabalProject , stackProject and hackage-package results in a lot of dependencies (all the dependencies of nix-tools for instance). They can be slow to calculate (even if no work needs to be done it is not unusual for it to take 5 seconds per project). They can be slow to build (or download) on machines that do not yet have them in the nix store. Hydra does not show progress because it does not provide feedback until it has a list of jobs and the list of jobs cannot depends on the nix being present (although this is often blamed on IFD it would be the same if it wrote out JSON files and read them in) When is it ok to materialize? \u00b6 The nix is unlikely to change frequently (and when it does you are happy to manually update it). You are happy to script something to update the materialized nix files automatically. You are certain that the IFD you materialize is not system -dependent. If it was you'd obtain different nix expressions depending on which system the IFD was evaluated. How can we materialize the nix files? \u00b6 Lets say we want to build hlint . We might start with an hlint file that looks like this: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; }; in hlint.components.exes.hlint Building this may result in a lot of output, but if you build it again it should give just: $ nix-build hlint.nix trace: Using latest index state for hlint! trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To materialize the nix files we need to take care to pin down the inputs. For cabalProject and hackage-package this means we must specify the index-state of hackage we want to use: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint.components.exes.hlint Now if we build again we get a hint telling use how to calculate a suitable sha256 hash to turn the derivation containing the nix files into a fixed output derivation: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/` /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint $ nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/ 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4 We can add the hash as plan-sha256 or ( stack-sha256 for stackProject ) let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; }; in hlint.components.exes.hlint Just adding the hash might help reuse of the cached nix, but nix will still calculate all the dependencies (which can add seconds to nix-build and nix-shell commands when no other work is needed) and users who do not yet have the dependencies in their store will have to wait while they are built or downloaded. Running nix build again gives us a hint on what we can do next: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: To materialize, point `materialized` to a copy of /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To capture the nix we can do something like: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; }; in hlint.components.exes.hlint Now we can copy the nix files needed and build with: $ cp -r /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs hlint.materialized $ nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint We may want to run chmod -R +w hlint.materialized as the files copied from the store will be read only. How can we check sha256 and materialized are up to date? \u00b6 Let's pretend we had to go back to hlint version 2.2.10 . We can tell haskell.nix to check the materialiazation either by: Removing the materialization files with rm -rf hlint.materialized Temporarily adding checkMaterialization = true; If we choose to add the checkMaterialization flag you would have: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; checkMaterialization = true; }; in hlint.components.exes.hlint This will fail and report the details of what is wrong and how to fix it: $ nix-build hlint.nix ... Calculated hash for hlint-plan-to-nix-pkgs was not 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4. New hash is : plan-sha256 = \"0zsi3wv92qax33ic4n5dfsqd1r9qam1k75za3c5jqgdxl3hy8vph\"; Materialized nix used for hlint-plan-to-nix-pkgs incorrect. To fix run : rm -rf /Users/hamish/iohk/haskell.nix/hlint.materialized cp -r /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs /Users/hamish/iohk/haskell.nix/hlint.materialized chmod -R +w /Users/hamish/iohk/haskell.nix/hlint.materialized builder for '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed with exit code 1 error: build of '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed (use '--show-trace' to show detailed location information) Checking the materialization requires nix to do all the work that materialization avoids. So while it might be tempting to leave checkMaterialization = true all the time, we would be better off just removing materialized and plan-sha256 . How can we update the nix files with a script? \u00b6 There are versions of the functions ( cabalProject' , stackProject' and hackage-project ) that also return the nix as plan-nix or stack-nix . By calling one of these functions without the hash and materialized nix we can find out what nix files should be. For instance: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-project { name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint $ nix-build hlint.nix -A plan-nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs/` /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs We can have the script copy $(nix-build hlint.nix -A plan-nix --no-out-link) and use nix-hash to calculate the new value for plan-sha256 . Can we skip making a copy and use materialized = /nix/store/... ? \u00b6 Yes and it gives us the same speed improvement, however: It does not help at all in restricted-eval mode (Hydra). Users will still wind up building or downloading the dependencies needed to build the nix fileds (if they do not have them). For those reasons it might be best to make a copy instead of using the /nix/store/... path directly. If you really want to use the /nix/store/... path directly you should gaurd against the path not existing as passing in a non-existing path is now an error: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlintPlan = /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = if __pathExists hlintPlan then hlintPlan else null; }; in hlint.components.exes.hlint Running when no building is needed is still slow in restricted evaluation mode. $ time nix-build --option restrict-eval true -I . --option allowed-uris \"https://github.com/NixOS https://github.com/input-output-hk\" hlint.nix --show-trace trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m4.463s user 0m4.440s sys 0m0.461s $ time nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m2.206s user 0m1.665s sys 0m0.332s","title":"Materialization"},{"location":"user-guide/materialization/#materialization","text":"","title":"Materialization"},{"location":"user-guide/materialization/#what-is-materialization","text":"Capturing and storing the nix files for a project so that they do not need to be built (or checked). This allows us to cache the input of an IFD (import from derviation).","title":"What is materialization?"},{"location":"user-guide/materialization/#why-use-materialization","text":"Using functions like cabalProject , stackProject and hackage-package results in a lot of dependencies (all the dependencies of nix-tools for instance). They can be slow to calculate (even if no work needs to be done it is not unusual for it to take 5 seconds per project). They can be slow to build (or download) on machines that do not yet have them in the nix store. Hydra does not show progress because it does not provide feedback until it has a list of jobs and the list of jobs cannot depends on the nix being present (although this is often blamed on IFD it would be the same if it wrote out JSON files and read them in)","title":"Why use materialization?"},{"location":"user-guide/materialization/#when-is-it-ok-to-materialize","text":"The nix is unlikely to change frequently (and when it does you are happy to manually update it). You are happy to script something to update the materialized nix files automatically. You are certain that the IFD you materialize is not system -dependent. If it was you'd obtain different nix expressions depending on which system the IFD was evaluated.","title":"When is it ok to materialize?"},{"location":"user-guide/materialization/#how-can-we-materialize-the-nix-files","text":"Lets say we want to build hlint . We might start with an hlint file that looks like this: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; }; in hlint.components.exes.hlint Building this may result in a lot of output, but if you build it again it should give just: $ nix-build hlint.nix trace: Using latest index state for hlint! trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To materialize the nix files we need to take care to pin down the inputs. For cabalProject and hackage-package this means we must specify the index-state of hackage we want to use: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint.components.exes.hlint Now if we build again we get a hint telling use how to calculate a suitable sha256 hash to turn the derivation containing the nix files into a fixed output derivation: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/` /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint $ nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/ 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4 We can add the hash as plan-sha256 or ( stack-sha256 for stackProject ) let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; }; in hlint.components.exes.hlint Just adding the hash might help reuse of the cached nix, but nix will still calculate all the dependencies (which can add seconds to nix-build and nix-shell commands when no other work is needed) and users who do not yet have the dependencies in their store will have to wait while they are built or downloaded. Running nix build again gives us a hint on what we can do next: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: To materialize, point `materialized` to a copy of /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To capture the nix we can do something like: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; }; in hlint.components.exes.hlint Now we can copy the nix files needed and build with: $ cp -r /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs hlint.materialized $ nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint We may want to run chmod -R +w hlint.materialized as the files copied from the store will be read only.","title":"How can we materialize the nix files?"},{"location":"user-guide/materialization/#how-can-we-check-sha256-and-materialized-are-up-to-date","text":"Let's pretend we had to go back to hlint version 2.2.10 . We can tell haskell.nix to check the materialiazation either by: Removing the materialization files with rm -rf hlint.materialized Temporarily adding checkMaterialization = true; If we choose to add the checkMaterialization flag you would have: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; checkMaterialization = true; }; in hlint.components.exes.hlint This will fail and report the details of what is wrong and how to fix it: $ nix-build hlint.nix ... Calculated hash for hlint-plan-to-nix-pkgs was not 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4. New hash is : plan-sha256 = \"0zsi3wv92qax33ic4n5dfsqd1r9qam1k75za3c5jqgdxl3hy8vph\"; Materialized nix used for hlint-plan-to-nix-pkgs incorrect. To fix run : rm -rf /Users/hamish/iohk/haskell.nix/hlint.materialized cp -r /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs /Users/hamish/iohk/haskell.nix/hlint.materialized chmod -R +w /Users/hamish/iohk/haskell.nix/hlint.materialized builder for '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed with exit code 1 error: build of '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed (use '--show-trace' to show detailed location information) Checking the materialization requires nix to do all the work that materialization avoids. So while it might be tempting to leave checkMaterialization = true all the time, we would be better off just removing materialized and plan-sha256 .","title":"How can we check sha256 and materialized are up to date?"},{"location":"user-guide/materialization/#how-can-we-update-the-nix-files-with-a-script","text":"There are versions of the functions ( cabalProject' , stackProject' and hackage-project ) that also return the nix as plan-nix or stack-nix . By calling one of these functions without the hash and materialized nix we can find out what nix files should be. For instance: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-project { name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint $ nix-build hlint.nix -A plan-nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs/` /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs We can have the script copy $(nix-build hlint.nix -A plan-nix --no-out-link) and use nix-hash to calculate the new value for plan-sha256 .","title":"How can we update the nix files with a script?"},{"location":"user-guide/materialization/#can-we-skip-making-a-copy-and-use-materialized-nixstore","text":"Yes and it gives us the same speed improvement, however: It does not help at all in restricted-eval mode (Hydra). Users will still wind up building or downloading the dependencies needed to build the nix fileds (if they do not have them). For those reasons it might be best to make a copy instead of using the /nix/store/... path directly. If you really want to use the /nix/store/... path directly you should gaurd against the path not existing as passing in a non-existing path is now an error: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs-default nixpkgsArgs; hlintPlan = /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs; hlint = pkgs.haskell-nix.hackage-package { name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = if __pathExists hlintPlan then hlintPlan else null; }; in hlint.components.exes.hlint Running when no building is needed is still slow in restricted evaluation mode. $ time nix-build --option restrict-eval true -I . --option allowed-uris \"https://github.com/NixOS https://github.com/input-output-hk\" hlint.nix --show-trace trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m4.463s user 0m4.440s sys 0m0.461s $ time nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m2.206s user 0m1.665s sys 0m0.332s","title":"Can we skip making a copy and use materialized = /nix/store/...?"},{"location":"user-guide/projects/","text":"How to replace IFDs with intermediate nix files \u00b6 We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"Creating Nix builds for your projects"},{"location":"user-guide/projects/#how-to-replace-ifds-with-intermediate-nix-files","text":"We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"How to replace IFDs with intermediate nix files"},{"location":"user-guide/source-repository-hashes/","text":"Source Repository Hashes \u00b6 Both stack.yaml and cabal.project files can contain references to git repositories containing the version of a particular package that we wish to use. This is mostly handled automatically by nix-tools and haskell.nix however when we want to use a nix system that is configured to use restricted mode (typically hydra) it will need an aditionaly hash. When using cabalProject or stackProject functions you can include the hash needed in a comment. To calculate the hash use nix-prefetch-git : $ nix-prefetch-git https://github.com/input-output-hk/haskell.nix.git bc01ebc05a8105035c9449943046b46c8364b932 ... { \"url\": \"https://github.com/input-output-hk/haskell.nix.git\", \"rev\": \"bc01ebc05a8105035c9449943046b46c8364b932\", \"date\": \"2019-05-30T13:13:18+08:00\", \"sha256\": \"003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z\", \"fetchSubmodules\": false } If you are using cabalProject add a --sha256 comment to the cabal.project file: source-repository-package type: git location: https://github.com/input-output-hk/haskell.nix.git tag: bc01ebc05a8105035c9449943046b46c8364b932 subdir: test/cabal-simple --sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z If you are using stackProject add a # nix-sha256 comment to the stack.yaml file: extra-deps: - git: https://github.com/input-output-hk/haskell.nix.git commit: bc01ebc05a8105035c9449943046b46c8364b932 subdirs: - test/cabal-simple # nix-sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z lookupSha256 \u00b6 In some cases we cannot modify the cabal.project file to add the --sha256 comments. As an alternative we can pass in a lookupSha256 function to get them. For instance pandoc includes a cabal.project file in hackage includes a source-package-reference to pandoc-citeproc : { haskell-nix, testSrc } : let pandoc = haskell-nix.hackage-package { name = \"pandoc\"; version = \"2.9.2.1\"; index-state = \"2020-04-15T00:00:00Z\"; # Function that returns a sha256 string by looking up the location # and tag in a nested attrset lookupSha256 = { location, tag, ... }: { \"https://github.com/jgm/pandoc-citeproc\".\"0.17\" = \"0dxx8cp2xndpw3jwiawch2dkrkp15mil7pyx7dvd810pwc22pm2q\"; } .\"${location}\".\"${tag}\"; }; in pandoc.components.exes.pandoc","title":"Source Repository Hashes"},{"location":"user-guide/source-repository-hashes/#source-repository-hashes","text":"Both stack.yaml and cabal.project files can contain references to git repositories containing the version of a particular package that we wish to use. This is mostly handled automatically by nix-tools and haskell.nix however when we want to use a nix system that is configured to use restricted mode (typically hydra) it will need an aditionaly hash. When using cabalProject or stackProject functions you can include the hash needed in a comment. To calculate the hash use nix-prefetch-git : $ nix-prefetch-git https://github.com/input-output-hk/haskell.nix.git bc01ebc05a8105035c9449943046b46c8364b932 ... { \"url\": \"https://github.com/input-output-hk/haskell.nix.git\", \"rev\": \"bc01ebc05a8105035c9449943046b46c8364b932\", \"date\": \"2019-05-30T13:13:18+08:00\", \"sha256\": \"003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z\", \"fetchSubmodules\": false } If you are using cabalProject add a --sha256 comment to the cabal.project file: source-repository-package type: git location: https://github.com/input-output-hk/haskell.nix.git tag: bc01ebc05a8105035c9449943046b46c8364b932 subdir: test/cabal-simple --sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z If you are using stackProject add a # nix-sha256 comment to the stack.yaml file: extra-deps: - git: https://github.com/input-output-hk/haskell.nix.git commit: bc01ebc05a8105035c9449943046b46c8364b932 subdirs: - test/cabal-simple # nix-sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z","title":"Source Repository Hashes"},{"location":"user-guide/source-repository-hashes/#lookupsha256","text":"In some cases we cannot modify the cabal.project file to add the --sha256 comments. As an alternative we can pass in a lookupSha256 function to get them. For instance pandoc includes a cabal.project file in hackage includes a source-package-reference to pandoc-citeproc : { haskell-nix, testSrc } : let pandoc = haskell-nix.hackage-package { name = \"pandoc\"; version = \"2.9.2.1\"; index-state = \"2020-04-15T00:00:00Z\"; # Function that returns a sha256 string by looking up the location # and tag in a nested attrset lookupSha256 = { location, tag, ... }: { \"https://github.com/jgm/pandoc-citeproc\".\"0.17\" = \"0dxx8cp2xndpw3jwiawch2dkrkp15mil7pyx7dvd810pwc22pm2q\"; } .\"${location}\".\"${tag}\"; }; in pandoc.components.exes.pandoc","title":"lookupSha256"},{"location":"user-guide/stack-projects/","text":"Here we will look into how to generate the pkgs.nix file for a stack.yaml project. For the full integration see the previous page . Using stack-to-nix \u00b6 With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = \"lts-12.17\"; extras = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ). Creating the package set \u00b6 Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Stack Projects"},{"location":"user-guide/stack-projects/#using-stack-to-nix","text":"With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = \"lts-12.17\"; extras = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ).","title":"Using stack-to-nix"},{"location":"user-guide/stack-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"}]}